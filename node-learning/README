Web Application Considerations

It’s astonishing that this lightweight script implements a functional web server. The app is permanently on, and it can retain its own state regardless of the number of users. For example, it could establish a database connection once at start-up, then reuse that same connection on every request. Apache/PHP environments are usually stateless, so every page request must load configuration parameters and connect to a database before running a query.

However, Node.js applications run on a single processing thread:

If your app fails, it fails for everyone and won’t restart unless you have appropriate monitoring in place. Options including PM2 and forever can help.
If a single user triggers a long-running JavaScript function that takes ten seconds to complete, every user accessing at that time will be waiting at least ten seconds for a response. Asynchronous code solves the problem, but it takes time to understand the concepts.
Scaling an application can be difficult. Throwing more RAM or CPUs onto an Apache/PHP server will improve response times. Node.js still runs on a single CPU core even when that CPU has 15 more at its disposal. Solutions such as clustering, PM2, and Docker containers can help by launching multiple instances of the same application.
In addition, Node.js web servers are not efficient at serving static files such as images, stylesheets, and client-side JavaScript. Production sites often use a front-end NGINX web server to serve static files or direct the request to the Node.js application when appropriate. This is known as a reverse proxy and it has benefits, such as:

Static assets are served without any Node.js interaction. This avoids unnecessary processing and improves performance.
Settings such as HTTPS certificates can be handled by NGINX rather than Node.js. This is especially practical when you have more than one instance of the same Node.js application running.
A Node.js app can run on a port above 1000, so it doesn’t need elevated superuser permissions.
Write Stateless Applications
Suppose your single Node.js app kept count of the number of logged-in users in single global variable named userCount.

What would happen if you wanted to improve performance by launching two or more instances of the same app—perhaps on other servers? Any instance could handle a user login. The userCount value would be different—and wrong—on each running instance of the app.

During development, you’ll often work on a single running instance. However, I recommend you make it stateless to ensure it can scale and be more resilient. Always presume:

multiple instances could be running anywhere, possibly on different ports or servers
an instance can be started or stopped at any time
a frontend web server will direct a single user’s request to any instance—regardless of which instance handled a previous request
In essence, avoid storing application or user state in variables or local files that could differ across instances. Use a database to retain state so every instance of the application can be synchronized.




SEMANTIC VERSIONING
Most Node.js projects use semantic versioning, with three MAJOR.MINOR.PATCH numbers such as 1.2.33. When a change occurs, you increment the appropriate number and zero those that follow:

MAJOR for major updates with incompatible API changes
MINOR for new functionality that doesn’t affect backwards compatibility
PATCH for bug fixes





Compressing HTTP Responses
To improve web application performance, you should compress assets before they’re returned to the browser over the network. The compression middleware module can handle this for you. Stop your app, then install the module:

npm install compression
The dependencies section of your package.json file updates accordingly:

  "dependencies": {
    "compression": "^1.7.4",
    "express": "^4.17.1"
  }
Load the module at the top of index.js:

// Express application
import express from 'express';
import compression from 'compression';
Then add it as one of the first middleware functions (before routers and static file handlers):

// HTTP compression
app.use( compression() );
It won’t make a noticeable difference to performance here, but addressing performance at the start of a project puts you one step ahead of most teams!